(()=>{"use strict";var e={709:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ATTRIB_NAME_VERTEX_POSITION=t.setupScreenRenderer=void 0,t.setupScreenRenderer=function(e,o){const i=function(e,t){const n=e.createShader(e.VERTEX_SHADER);if(e.shaderSource(n,r),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))return console.error("Failed to compile vertex shader:\n"+e.getShaderInfoLog(n)),void e.deleteShader(n);const o=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(o,t),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS))return console.error("Failed to compile fragment shader:\n"+e.getShaderInfoLog(o)),e.deleteShader(n),void e.deleteShader(o);const i=e.createProgram();return e.attachShader(i,n),e.attachShader(i,o),e.linkProgram(i),e.getProgramParameter(i,e.LINK_STATUS)?(e.deleteShader(n),e.deleteShader(o),i):(console.error("Failed to link shader program:\n"+e.getProgramInfoLog(i)),e.deleteShader(n),e.deleteShader(o),void e.deleteProgram(i))}(e,o);if(null!=i)return function(e,r){const o=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW);const i=e.getAttribLocation(r,t.ATTRIB_NAME_VERTEX_POSITION);e.vertexAttribPointer(i,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(i)}(e,i),i},t.ATTRIB_NAME_VERTEX_POSITION="aPos";const r=`attribute lowp vec2 ${t.ATTRIB_NAME_VERTEX_POSITION};void main(){gl_Position=vec4(${t.ATTRIB_NAME_VERTEX_POSITION},0,1);}`,n=new Float32Array([1,1,-1,1,1,-1,-1,-1])}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}(()=>{const e=r(709);window.onload=function(){let t=document.getElementById("canvas");t.width=window.innerWidth,t.height=window.innerHeight;let r=t.getContext("webgl",{alpha:!1});if(null===r)return void alert("Unable to initialize WebGL. Looks like your browser does not support it!");const n=e.setupScreenRenderer(r,"\nconst int MAX_LOOP = 4096;\nuniform lowp vec2 uRes;\n\nuniform highp vec4 uRect;\nuniform int uLimit;\nuniform lowp vec4 uLimitColor;\n\nhighp vec2 csqr(in vec2 z) {\n\treturn vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y);\n}\n\nint mandel(in vec2 c) {\n\thighp vec2 z = vec2(0);\n\tfor (int i = 0; i < MAX_LOOP; ++i) {\n\t\tz = csqr(z) + c;\n\t\tif (i >= uLimit || dot(z, z) >= 4.) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn uLimit;\n}\n\nvoid main() {\n\thighp vec2 coord = uRect.xy + uRect.zw * (gl_FragCoord.xy / uRes);\n\tint val = mandel(coord);\n\tif (val == uLimit) {\n\t\tgl_FragColor = uLimitColor;\n\t} else {\n\t\tlowp float fval = float(val)/float(uLimit);\n\t\tgl_FragColor = vec4(fval, fval, fval, 1);\n\t}\n}\n");if(null==n)return;r.useProgram(n);const o={res:r.getUniformLocation(n,"uRes"),rect:r.getUniformLocation(n,"uRect"),limit:r.getUniformLocation(n,"uLimit"),limitColor:r.getUniformLocation(n,"uLimitColor")},i=t.width/t.height;r.uniform2f(o.res,t.width,t.height),r.uniform4f(o.rect,-1*i,-1,2*i,2),r.uniform1i(o.limit,32),r.uniform4f(o.limitColor,0,0,0,0),r.drawArrays(r.TRIANGLE_STRIP,0,4)}})()})();