<!DOCTYPE html>

<html>

<head>
    <link rel="stylesheet" href="/style/light.css">
    <meta name="author" content="Grigory 'Technomunk' Glukhov">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:url" content="https://www.technomunk.com/">
    <meta property="og:site_name" content="Technomunk">
    <meta property="og:title" content="Technomunk on: Assembly">
    <meta property="og:description" content="10-minute crash course to demystify assembly languages">
    <meta property="og:image" content="img/avatar.jpg" />
    <title>Technomunk on: Assembly</title>
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="theme-color" content="#333333">
    <meta name="color-scheme" content="light dark">
</head>

<body>
    <main>
        <p class="strong">Assembly</p>
        <p>Assembly is a family of low-level programming languages that generally look like this:</p>
        <pre><code class="language-x86asm">; find an integer that is close to the square root of edi
find_integer_square_root:
    mov     eax, 0
guess_a_root:
    inc     eax
    mov     ecx, eax
    mul     ecx, eax
    cmp     ecx, edi
    jb      guess_a_root
    ret
</code></pre>
        <p>You may have heard that computers think in <strong>binary</strong>, which is true. They only understand 1s
            and 0s, so the programs that computers read are long sequences of just that. These binary instructions are
            called <dfn>machine code</dfn> and in the early days of programming - people had to create programs in 1s
            and 0s using punch-cards, weaving wires through copper loops or typing them in on a keyboard. As you can
            imagine - such a process is very tedious and mistakes are difficult to spot or correct. So something more
            human-friendly was invented - <dfn>assembly languages</dfn>. The name likely stems from the fact that these
            programs can't be executed by computers directly, rather they need to be "assembled" into machine code
            first.</p>
        <!-- TODO: cite references -->
        <p>Cool, but that doesn't explain why supposedly human-friendly instructions look like collections of random
            letters to a lay person. And the reason is that the assembly is very closely related to the machine code it
            is assembled into. Think of translation services, when you use them to translate a single word or a phrase -
            you typically get an excellent translation. But try to translate whole sentences, paragraphs and texts - the
            results are quite often imperfect. Same is true with programming languages. The more translation that needs
            to happen - the more difficult it is to make good translations and ensure the computer does exactly what we
            think it will do.</p>
        <!-- TODO: callout to uses that require knowing exactly what the computer does-->
        <p>I promised that you will be able to read the piece of code the blog started with, so with the history out of
            the way - let's get to it. And thankfully our example starts with something simple - a comment: <code
                class="language-x86asm">; find an integer that is close to the square root of edi</code>. The
            semi-column is a marker that the following text does not represent instructions to be executed by the
            computer.</p>
        <p>Next line <code class="language-x86asm">find_integer_square_root:</code> however is a little more complex. It
            is a <dfn>label</dfn>. You might think it's a title of our program. But to an assembler - it's a marker that
            it needs to remember that specific place in the program. Why would it need to remember it? Well we might
            want to find the square root of several numbers in our program and it would become tedious to copy the same
            instructions all over the place and computers are able to jump to a specific place in the machine code, so
            we could jump to our square-root <dfn>routine</dfn>, execute it and then return to whatever the bigger
            program was doing. The label tells the assembler we might want to jump to the following instruction at some
            other point.
        </p>
        <p><code class="language-x86asm">mov eax, 0</code> is the first instruction of our program! It tells the
            computer to <strong>move</strong> the value 0 into <dfn>register</dfn> <strong>eax</strong>. A register is a
            very small amount of very fast memory that computers use to perform their calculations. Think of it like a
            cutting board in the kitchen. While cooking you might move ingredients out of the fridge onto the cutting
            board before slicing them. Computers do the same - load data from memory or external devices into their
            registers before performing calculations on those values. Because there might be some other value in the
            register <dfn>eax</dfn> - we set it to 0 before calculating the square root.</p>
        <!-- TODO: explain register naming in x86 -->
        <p><code class="language-x86asm">guess_a_root:</code> is another label that we will use shortly. For now let's
            move onto <code class="language-x86asm">inc eax</code>. This instruction tells the computer to increment
            (add 1) to the value in register <strong>eax</strong>.</p>
        <p>The increment is followed by <code class="language-x86asm">move ecx, eax</code>. It's another
            <strong>move</strong> instruction, this time we are moving the value from register <strong>eax</strong> into
            <strong>ecx</strong>. Note that <strong>move</strong> is perhaps a misnomer here, as the value is copied
            from the source. That is because it's physically simpler to copy 1s and 0s and then remove them than to
            actively move them around. Another perhaps counter-intuitive quirk of many assembly languages is that the
            destination of an operation comes first. In English we say "move from A to B", however it's simpler to
            design hardware that prefers "move into B from A" and as assembly is very close to machine language - it
            mirrors that design.
        </p>
        <!-- TODO: shout-out why it's simpler to design such languages -->
        <p>So far it's not clear how incrementing and copying some values helps us find the square root of a number. The
            next operation might give us a clue: <code class="language-x86asm">mul ecx, eax</code>. Here we tell the
            computer to multiply the values in <strong>ecx</strong> and <strong>eax</strong> together and store the
            result in <strong>ecx</strong> (yes, we use the first register as both source and destination of data). And
            because we just copied the value from <strong>eax</strong> - effectively we squared whatever value was there
            (so far it should be 1). Aha! So to find the square root looks like our program squares consecutive integers
            until it finds the first one that is larger than our number.</p>
        <p><code class="language-x86asm">cmp ecx, edi</code> might make sense now, if you're following along. We are
            comparing the values in <strong>ecx</strong> and <strong>edi</strong> registers. <strong>ecx</strong>
            contains the square of our guess and <strong>edi</strong> therefore must be the number we want to find the
            square root of. But where do we store the result of our comparison? You might think it is stored in
            <strong>ecx</strong>, as it's the first register in our instruction and so far that has always been the
            destination of any operation. And some computers might work like that, but the engineers designing x86 (the
            computer architecture our example is using) realized that quite often we want to keep our compared values in
            registers. So what happens in our case is the result of the comparison is remembered by the computer in a
            different special register. Just keep it in mind for now.
        </p>
        <p><code class="language-x86asm">jb guess_a_root</code> is referencing a label. And it immediately follows a
            comparison operation... If we put the two together - we might come to the correct conclusion that we tell
            the computer to go back to <strong>guess_a_root</strong> if the square of our guessed root value is smaller
            than the argument to our function. The instruction in question is called <dfn><b>j</b>ump if
                <b>b</b>elow</dfn>. The jump part stems from the fact that we are skipping to some other place in our
            program instead of following along. And below should be self-explanatory: only perform the jump if our
            compared value is below (smaller than) the second value. This instruction is using the remembered result of
            comparison in the special register that was just mentioned.</p>
        <p>Finally we come to the <code class="language-x86asm">ret</code> instruction. This one tells the computer that
            our square-root function is done and the computer should <strong>return</strong> to whatever it was doing
            before trying to find the square-root of the value in <strong>edi</strong>.</p>
        <p>Putting it all together our program does the following:
        <ol>
            <li>Set the guess to 0</li>
            <li>Increment a guessed square-root by 1</li>
            <li>Square the guess</li>
            <li>Check if the square of the guess is smaller or equal to the argument</li>
            <li>Go back to 2 if it is</li>
            <li>Return with our best match for the square root of an integer in <strong>ecx</strong></li>
        </ol>
        </p>
        <p>So if we expand our program, we can find the square root of any number by doing the following:
        <pre><code class="language-x86asm">    mov     edi, 8
    call    sqrt
    ; the square root of whatever was in edi is now in ecx
    </code></pre>
        Note the <code class="language-x86asm">call sqrt</code>. This instruction is telling the computer to remember
        where it is right now so that it knows where to return to and start executing instructions under the
        <strong>sqrt</strong> label.
        </p>
    </main>
</body>

</html>
