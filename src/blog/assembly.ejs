<!DOCTYPE html>

<html>

<head>
    <link rel="stylesheet" href="/style/light.css">
    <meta name="author" content="Grigory 'Technomunk' Glukhov">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:url" content="https://www.technomunk.com/">
    <meta property="og:site_name" content="Technomunk">
    <meta property="og:title" content="Technomunk on: Assembly">
    <meta property="og:description" content="10-minute crash course to demystify assembly languages">
    <meta property="og:image" content="img/avatar.jpg" />
    <title>Technomunk on: Assembly</title>
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="theme-color" content="#333333">
    <meta name="color-scheme" content="light dark">
</head>

<body>
    <main>
        <p class="em">Assembly</p>
        <p>Assembly is a family of low-level programming languages that generally look like this:</p>
        <pre class="interactive-container"><code id="code" class="interactive x86asm">; find an integer that is close to the square root of edi
find_integer_square_root:
    mov     ax, 0
guess_a_root:
    inc     ax
    mov     cx, ax
    mul     cx, ax
    cmp     cx, di
    jb      guess_a_root
    ret
</code></pre>
        <p>You may have heard that computers think in <em>binary</em>, which is true. They only understand 1s and 0s, so
            the programs that computers read are long sequences of just that. These binary instructions are called
            <dfn>machine code</dfn> and in the early days of programming - people had to create programs in 1s and 0s
            using punch-cards, weaving wires through copper loops or typing them in on a keyboard. As you can imagine -
            such a process is very tedious and mistakes are difficult to spot or correct. So something more
            human-friendly was invented - <dfn>assembly languages</dfn>. The name stems from the fact that these
            programs can't be executed by computers directly, rather they need to be <cite><a
                    href="https://www.britannica.com/topic/The-Preparation-of-Programs-for-an-Electronic-Digital-Computer">assembled</a></cite>
            into machine code first. Perhaps a more accurate term would be <em>assemblee language</em> but history chose
            otherwise.
        </p>
        <p>And because there are many different processor architectures with different machine code - for the most part
            each one requires its own assembly code. The example I chose is <dfn>x86</dfn>, which is extremely
            widespread - servers, desktops, most laptops and even consoles run some version of x86. There is a myriad
            of other architectures used in various applications, however once you understand this piece of code - you
            will be able to understand the gist of any assembly language.</p>
        <p>Cool, but that doesn't explain why supposedly human-friendly instructions look like collections of random
            letters to a lay person. And the reason is that the assembly is very closely related to the machine code it
            is assembled into. Think of translation services, when you use them to translate a single word or a phrase -
            you typically get an excellent translation. But try to translate whole sentences, paragraphs and texts - the
            results are quite often imperfect. Same is true with programming languages. The more translation that needs
            to happen - the more difficult it is to make good translations and ensure the computer does exactly what we
            think it will do.</p>
        <p>I promised that you will be able to read the piece of code the blog started with, so with the history out of
            the way - let's get to it. And thankfully our example starts with something simple - a comment: <code
                class="x86asm">; find an integer that is close to the square root of edi</code>. The semi-column is a
            marker that the following text does not represent instructions to be executed by the computer.</p>
        <p>Next line <code class="x86asm">find_integer_square_root:</code> however is a little more complex. It is a
            <dfn>label</dfn>. You might think it's a title of our program. But to an assembler - it's a marker that it
            needs to remember that specific place in the program. Why would it need to remember it? Well we might want
            to find the square root of several numbers in our program and it would become tedious to copy the same
            instructions all over the place and computers are able to jump to a specific place in the machine code, so
            we could jump to our square-root <dfn>routine</dfn>, execute it and then return to whatever the bigger
            program was doing. The label tells the assembler we might want to jump to the following instruction at some
            other point.
        </p>
        <p><code class="x86asm">mov ax, 0</code> is the first instruction of our program! It tells the computer to
            <em>move</em> the value 0 into <dfn>register</dfn> <em>ax</em>. A register is a very small amount of very
            fast memory that computers use to perform their calculations. Think of it like a cutting board in the
            kitchen. While cooking you might move ingredients out of the fridge onto the cutting board before slicing
            them. Computers do the same - load data from memory or external devices into their registers before
            performing calculations on those values. Because there might be some other value in the register
            <dfn>ax</dfn> - we set it to 0 before calculating the square root.
        </p>
        <p>x86 has a bunch of varying registers, the ones we are interested in are general purpose ones: <dfn>AX:
                accumulator register</dfn>, <dfn>CX - counter register</dfn> and <dfn>DI - destination index</dfn>. The
            names hint at the intended usecase, however you can treat them as odd variable names.</p>
        <p><code class="x86asm">guess_a_root:</code> is another label that we will use shortly. For now let's move onto
            <code class="x86asm">inc ax</code>. This instruction tells the computer to increment (add 1) to the value
            in register <em>ax</em>.
        </p>
        <p>The increment is followed by <code class="x86asm">mov cx, ax</code>. It's another <em>move</em> instruction,
            this time we are moving the value from register <em>ax</em> into <em>cx</em>. Note that <em>move</em> is
            perhaps a misnomer here, as the value is copied from the source. That is because it's physically simpler to
            copy 1s and 0s and then remove them than to actively move them around. Another perhaps counter-intuitive
            quirk of many assembly languages is that the destination of an operation comes first. In English we say
            "move from A to B", however it's simpler to design hardware that prefers "move into B from A" and as
            assembly is very close to machine language - it mirrors that design.
        </p>
        <!-- TODO: shout-out why it's simpler to design such languages -->
        <p>So far it's not clear how incrementing and copying some values helps us find the square root of a number. The
            next operation might give us a clue: <code class="x86asm">mul cx, ax</code>. Here we tell the computer to
            multiply the values in <em>cx</em> and <em>ax</em> together and store the result in <em>cx</em> (yes, we use
            the first register as both source and destination of data). And because we just copied the value from
            <em>ax</em> - effectively we squared whatever value was there (so far it should be 1). Aha! So to find the
            square root looks like our program squares consecutive integers until it finds the first one that is larger
            than our number.
        </p>
        <p><code class="x86asm">cmp cx, di</code> might make sense now, if you're following along. We are comparing the
            values in <em>cx</em> and <em>di</em> registers. <em>cx</em> contains the square of our guess and
            <em>edi</em> therefore must be the number we want to find the square root of. But where do we store the
            result of our comparison? You might think it is stored in <em>cx</em>, as it's the first register in our
            instruction and so far that has always been the destination of any operation. And some computers might work
            like that, but the engineers designing x86 realized that quite often we want to keep our compared values in
            registers. So what happens in our case is the result of the comparison is remembered by the computer in a
            different special register. Just keep it in mind for now.
        </p>
        <p><code class="x86asm">jb guess_a_root</code> is referencing a label. And it immediately follows a comparison
            operation... If we put the two together - we might come to the correct conclusion that we tell the computer
            to go back to <em>guess_a_root</em> if the square of our guessed root value is smaller than the argument to
            our function. The instruction in question is called <dfn><b>j</b>ump if <b>b</b>elow</dfn>. The jump part
            stems from the fact that we are skipping to some other place in our program instead of following along. And
            below should be self-explanatory: only perform the jump if our compared value is below (smaller than) the
            second value. This instruction is using the remembered result of comparison in the special register that was
            just mentioned.</p>
        <p>Finally we come to the <code class="x86asm">ret</code> instruction. This one tells the computer that
            our square-root function is done and the computer should <em>return</em> to whatever it was doing
            before trying to find the square-root of the value in <em>edi</em>.</p>
        <p>Putting it all together our program does the following:
        <ol>
            <li>Set the guess to 0</li>
            <li>Increment a guessed square-root by 1</li>
            <li>Square the guess</li>
            <li>Check if the square of the guess is smaller or equal to the argument</li>
            <li>Go back to 2 if it is</li>
            <li>Return with our best match for the square root of an integer in <em>ecx</em></li>
        </ol>
        </p>
        <p>So if we expand our program, we can find the square root of any number by doing the following:
        <pre><code class="x86asm">    mov     di, 8
    call    find_integer_square_root
    ; the square root of whatever was in di is now in cx
    </code></pre>
        Note the <code class="x86asm">call find_integer_square_root</code>. This instruction is telling the computer to
        remember where it is right now so that it knows where to return to and start executing instructions under the
        <em>find_integer_square_root</em> label.
        </p>
        <p>You might be wondering whether assembly is still useful in modern day and age when we have much more
            ergonomic ways of programming. And it is! A prime example is performance fine-tuning: looking at compiled
            assembly to see where the CPU might be wasting time with slow operations and perhaps manually tweaking it to
            squeeze those last few percentages of improvement! Another good example is in cryptography. If the computer
            uses different amount of energy or time to check a password - there is a potential vulnerability where the
            attacker can measure how much energy or time was spent to get what the password was! To avoid such
            possibility - someone can look through assembly and ensure the calculation always takes the exact same path
            with any input.
        </p>
    </main>
</body>

</html>
